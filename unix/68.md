# UNIX 进程管理 - Unix

当你执行一个程序在UNIX系统上，该系统为该程序创建一个特殊的环境。这个环境包含系统运行的程序，如果没有其他程序在系统上运行所需要的一切。

每当你发出命令在UNIX中，创建或启动一个新的进程。当你尝试了合列出目录的内容，你启动了一个进程。一个过程，简单来说，就是一个正在运行的程序的一个实例。

操作系统将跟踪进程称为PID或进程ID通过五位ID号。该系统中的每个进程都有一个唯一的pid。

PIDS最终重复，因为所有可能的数字和未来的PID滚动或重新开始。在任何一个时间，没有两个具有相同的pid的进程在系统中存在，因为它是UNIX使用跟踪每个进程的pid。

## 启动进程：

当你启动一个进程（运行命令），您可以运行它有两种方法：

*   前台进程

*   后台进程

## 前台进程：

默认情况下，每一个过程，你开始在前台运行。从键盘输入，并将其输出到屏幕上。

使用ls命令，你可以看到这一点。如果我要列出当前目录中的所有文件，就可以使用下面的命令：

```
$ls ch*.doc
```

这将显示所有文件的名称开始ch和结束以 .doc：

```
ch01-1.doc   ch010.doc  ch02.doc    ch03-2.doc 
ch04-1.doc   ch040.doc  ch05.doc    ch06-2.doc
ch01-2.doc   ch02-1.doc
```

程序在前台运行，输出定向到我的屏幕，如果ls命令希望任何输入（事实并非如此），它会等待从键盘。

当程序在前台运行，并采取太多的时间，我们不能运行任何其他命令（启动任何其他的进程），因为提示将无法使用，直到程序完成其加工出来。

## 后台进程：

后台进程运行，而无需连接到你的键盘。如果后台进程需要任何键盘输入，它会等待。

进程在后台运行的优点是，你可以运行其他命令，你不必等待，直到它完成启动另一个！

启动一个后台进程的最简单的方法是在命令末尾添加一个符号（&）。

```
$ls ch*.doc &
```

这也将显示所有文件的名称开始ch和结束的 .doc：

```
ch01-1.doc   ch010.doc  ch02.doc    ch03-2.doc 
ch04-1.doc   ch040.doc  ch05.doc    ch06-2.doc
ch01-2.doc   ch02-1.doc
```

这里如果ls命令希望任何输入（事实并非如此），进入停止状态，直到我把它移动到前台，并给它的数据从键盘。

也就是说第一行包含有关后台进程的信息 - 工作的数量和进程ID。你需要了解作业的数量，操纵它在前台和后之间。

如果你现在按下回车键，看到以下内容：

```
[1]   +   Done                 ls ch*.doc &
$
```

第一行告诉你ls命令的后台进程成功完成。第二个是另一个命令提示。

## 列出正在运行的进程：

这是很容易看到自己的进程运行的ps（进程状态）命令如下：

```
$ps
PID       TTY      TIME        CMD
18358     ttyp3    00:00:00    sh
18361     ttyp3    00:01:31    abiword
18789     ttyp3    00:00:00    ps
```

其中最常用的标志 **-f** ( f for full) 选项，它提供了更多的信息，如下面的示例所示：

```
$ps -f
UID      PID  PPID C STIME    TTY   TIME CMD
amrood   6738 3662 0 10:23:03 pts/6 0:00 first_one
amrood   6739 3662 0 10:22:54 pts/6 0:00 second_one
amrood   3662 3657 0 08:10:53 pts/6 0:00 -ksh
amrood   6892 3662 4 10:51:50 pts/6 0:00 ps -f
```

这里是ps-f命令显示的所有字段的描述：

| Column | 描述 |
| --- | --- |
| **UID** | User ID that this process belongs to (the person running it). |
| **PID** | Process ID. |
| **PPID** | Parent process ID (the ID of the process that started it). |
| **C** | CPU utilization of process. |
| **STIME** | Process start time. |
| **TTY** | Terminal type associated with the process |
| **TIME** | CPU time taken by the process. |
| **CMD** | The command that started this process. |

还有其他的选择可以一起使用ps命令：

| Option | 描述 |
| --- | --- |
| **-a** | Shows information about all users |
| **-x** | Shows information about processes without terminals. |
| **-u** | Shows additional information like -f option. |
| **-e** | Display extended information. |

## 停止进程：

几种不同的方法可以做到在结束过程。通常情况下，从一个基于控制台的命令，发送CTRL + C按键（默认中断字符）将退出命令。这工作进程正在运行时在前台模式。

如果一个进程在后台模式下运行，那么首先你需要得到其作业ID，使用ps命令后，你可以使用kill命令来杀死进程如下：

```
$ps -f
UID      PID  PPID C STIME    TTY   TIME CMD
amrood   6738 3662 0 10:23:03 pts/6 0:00 first_one
amrood   6739 3662 0 10:22:54 pts/6 0:00 second_one
amrood   3662 3657 0 08:10:53 pts/6 0:00 -ksh
amrood   6892 3662 4 10:51:50 pts/6 0:00 ps -f
$kill 6738
Terminated
```

这里kill命令将终止first_one的过程。如果一个进程忽略了正规的kill命令，你可以使用kill-9进程ID如下：

```
$kill -9 6738
Terminated
```

## 父进程和子进程：

每个UNIX进程有两个ID号分配给它的进程ID（PID）和父进程ID（PPID）。系统中的每一个用户进程都有一个父进程。

您运行的大部分命令作为其父的shell。检查ps -f 这个命令列出进程ID和父进程ID。

## 僵尸和孤儿进程：

通常情况下，当一个孩子被杀害，被告知父进程通过一个SIGCHLD信号。然后，父进程可以做一些其他的任务，或者需要重新启动一个新的子进程。然而，有时父进程在子进程之前被杀死。在这种情况下，“父的所有进程，”init进程，成为新的PPID（父进程ID）。有时，这些进程被称为孤儿进程。

当一个进程被杀死，ps列出可能仍然显示一个Z状态的过程。这是一具僵尸或解散过程。进程是死的，不被使用。这些过程是不同于孤立进程。它们是已完成执行的处理，但仍然有进程表中的一个条目。

## 守护进程：

守护进程是系统相关的后台进程，往往根和服务请求来自其他进程的权限运行。

守护进程没有控制终端。它不能打开/dev/tty。如果你用“ps-ef”，并期待在tty字段中，所有的守护进程将有一个吗？ tty。

更清楚的是，仅仅是一个守护进程在后台运行的进程，通常在等待一些事情发生，它是有能力的工作，就像一台打印机守护进程正在等待打印命令。

如果你有一个程序需要做长期处理，那么使其成为一个守护进程，它在后台运行。

## top命令：

top命令是一个非常有用的工具，用于快速显示按各种标准排序的的进程。

这是一个互动的诊断工具，经常更新，并显示物理和虚拟内存，CPU使用率，平均负载，以及您繁忙的的进程的信息。

下面是简单的语法来运行top命令，并看到不同进程的CPU利用率的统计：

```
$top
```

## 作业ID与进程ID：

背景和暂停的的进程通常是通过操纵作业号（作业ID）。这个数字是不同的进程ID的使用，因为它是短暂的。

此外，作业可包含串联或在同一时间运行，并联的多个进程，因此，使用的作业ID是容易跟踪单个进程。

 